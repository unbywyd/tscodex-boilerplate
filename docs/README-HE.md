# TSCodex BluePrint - האלגוריתם והייחודיות

## מה הופך את הפרויקט הזה לייחודי?

### 1. **אבלוריתם אדפטיבי חכם**
המערכת לא עובדת באותו אופן לכל פרויקט. היא מתאימה את עצמה למורכבות הפרויקט:

- **Simple** - פרויקטים פשוטים מקבלים workflow מקוצר (5 שלבים)
- **Medium** - פרויקטים בינוניים מקבלים workflow מלא (8 שלבים)
- **Complex** - פרויקטים מורכבים מקבלים פירוק למודולים + workflow מלא

**התוצאה:** לא מבזבזים זמן על שלבים מיותרים, אבל גם לא מדלגים על דברים חשובים.

### 2. **מקור אמת אחד (Single Source of Truth)**
כל המידע על הפרויקט נמצא בקבצים פשוטים (TOML/Markdown):
- המפרט הטכני
- התיעוד
- הנתונים לדוגמה
- הסכמה של המסד הנתונים

**מה זה אומר?** כשמשנים משהו במפרט - הכל מתעדכן אוטומטית. אין צורך לשמור סינכרון בין תיעוד לקוד.

### 3. **דיאלוג מובנה עם LLM**
המערכת מנחה את ה-LLM לשאול את השאלות הנכונות, במינון הנכון:
- פרויקט פשוט = שאלות קצרות ומהירות
- פרויקט מורכב = שאלות מעמיקות עם כל הפרטים

**התוצאה:** LLM יודע בדיוק מה לשאול ומתי, ולא מבלבל את המשתמש.

### 4. **יצירה אוטומטית של תיעוד ופרוטוטייפ**
מאותם קבצים נוצרים:
- פורטל תיעוד יפה ומאורגן
- פרוטוטייפ React עובד עם נתונים מזויפים
- סכמת Prisma למסד נתונים

**התוצאה:** כתיבה אחת = שלושה תוצרים.

---

## האלגוריתם: איך זה עובד?

### שלב 0: Assessment (הערכה)

**מטרה:** להבין את המורכבות של הפרויקט ולבחור פרופיל.

המערכת שואלת:
- איזה סוג פרויקט? (web-app, mobile, api...)
- כמה תפקידי משתמשים? (אחד, 2-3, הרבה)
- כמה מורכבים הנתונים? (פשוט, יחסי, היררכיה מורכבת)
- יש אינטגרציות חיצוניות? (לא, כמה, הרבה)

**החלטה:** המערכת בוחרת פרופיל:
- **Simple** - עבור landing pages, פורטפוליו, אפליקציות CRUD פשוטות
- **Medium** - עבור SaaS, e-commerce, אפליקציות מרובות תפקידים
- **Complex** - עבור ERP, marketplaces, מערכות enterprise

**מה קורה אחר כך?** המערכת יודעת איזה שלבים לדלג ואיזה עומק לשאול.

---

### שלב 1: Discovery (גילוי)

**מטרה:** להבין את היסודות של הפרויקט.

**Simple:** שאלות קצרות
- מה זה במילה אחת?
- מי ישתמש?
- מה הפעולה העיקרית?

**Medium:** שאלות מפורטות
- מה הבעיה שזה פותר?
- מי הקהל?
- מה הערך המרכזי?
- מה 5 התכונות העיקריות?

**Complex:** שאלות מעמיקות
- כל מה שב-Medium +
- מה המטרות העסקיות?
- אילו מערכות קיימות צריך לשלב?
- מה דרישות התאימות?
- מה הצפי לקנה מידה?

**תוצר:** קבצי TOML עם כל המידע שנאסף.

---

### שלב 2: Design (עיצוב) - אופציונלי

**מתי:** רק עבור Medium ו-Complex.

**מטרה:** להגדיר דרישות ויזואליות ו-UX.

**שאלות:**
- עיצוב מותאם אישית או UI kit סטנדרטי?
- העדפות צבעים?
- Mobile-first או desktop-first?
- יש הנחיות מיתוג?

**תוצר:** `layers/project/design.toml`

---

### שלב 3: Access Control (בקרת גישה)

**מתי:** רק אם יש יותר מתפקיד משתמש אחד.

**מטרה:** להגדיר מי יכול לעשות מה.

**Simple:** מדלגים (תפקיד אחד = אין צורך)

**Medium:** 
- רשימת כל סוגי המשתמשים
- מה כל תפקיד יכול לעשות?
- אילו דפים מוגנים?

**Complex:**
- כל מה שב-Medium +
- היררכיה של תפקידים
- הרשאות ברמת שדה
- שיקולי multi-tenant

**תוצר:** `layers/roles/*.toml`, `layers/guards/*.toml`

---

### שלב 4: Data Model (מודל נתונים)

**מטרה:** להגדיר entities ויחסים ביניהם.

**Simple:**
- מה האובייקטים העיקריים? (2-5)
- מה השדות של כל אחד?

**Medium:**
- כל ה-entities עם הגדרות שדות מלאות
- יחסים בין entities
- שדות חובה מול אופציונליים
- כללי ולידציה

**Complex:**
- כל מה שב-Medium +
- הרשאות ברמת שדה
- audit trails
- דרישות soft delete
- מחזור חיים של נתונים
- שיקולי ביצועים ואינדקסים

**תוצר:** `layers/entities/*.toml`

---

### שלב 5: Features & Screens (תכונות ומסכים)

**מטרה:** להגדיר מה המשתמשים יכולים לעשות ומה הם רואים.

**Simple:**
- רשימת המסכים העיקריים (3-5)
- מה הזרימה הראשית?

**Medium:**
- Use cases עם user stories
- כל ה-routes/מסכים
- קומפוננטות דף עם הרכבה
- Happy path + טיפול שגיאות בסיסי

**Complex:**
- כל מה שב-Medium +
- זרימות חלופיות
- מקרי קצה
- התאוששות משגיאות
- מצבי loading/empty
- התנהגות offline

**תוצר:** `layers/use-cases/*.toml`, `layers/routes/*.toml`, `layers/components/*.toml`

---

### שלב 6: Modules (מודולים) - רק ל-Complex

**מתי:** רק עבור פרויקטים מורכבים מאוד.

**מטרה:** לפרק פרויקטים גדולים לדומיינים ניהוליים.

**מתי להשתמש:**
- יותר מ-10 entities
- יותר מ-5 זרימות משתמש שונות
- מספר צוותים עובדים על הפרויקט
- יש גבולות דומיין ברורים

**תהליך:**
1. זיהוי דומיינים (למשל: auth, catalog, orders, payments)
2. יצירת הגדרת מודול לכל אחד
3. כל מודול עובר שלבים 4-5 באופן עצמאי
4. הגדרת ממשקים בין מודולים

**תוצר:** `layers/modules/*.toml`

---

### שלב 7: Prototype (פרוטוטייפ)

**מטרה:** מסכי React עובדים עם נתונים מזויפים.

**מה קורה:**
- יצירת JSON מזויף מה-entities
- יצירת קומפוננטות דף ב-`src/prototype/`
- יישום ניווט
- חיווט טפסים (ללא backend)

**תוצר:**
- `src/prototype/mocks/*.json`
- `src/prototype/pages/*.tsx`
- `src/prototype/components/**/*.tsx`

**למה לפני Schema?** הפרוטוטייפ עובד עם נתונים מזויפים (JSON) ולא צריך מסד נתונים אמיתי. זה מאפשר לבדוק את ה-UI/UX במהירות לפני שמתחייבים לסכמה סופית.

---

### שלב 8: Schema (סכמה)

**מטרה:** סכמת מסד נתונים מוכנה ליישום.

**מה קורה:**
- יצירת Prisma schema מה-entities
- הוספת relations
- הוספת indexes
- ולידציה

**תוצר:** `prisma/schema.prisma`

**למה אחרי Prototype?** 
1. **בדיקה ראשונה** - הפרוטוטייפ מאפשר לבדוק את הרעיון לפני יצירת סכמה מורכבת
2. **למידה מהשימוש** - אחרי שימוש בפרוטוטייפ, מבינים טוב יותר מה באמת צריך במסד הנתונים
3. **גמישות** - אפשר לשנות entities בפרוטוטייפ בלי להתחייב לסכמה סופית
4. **הפרדה** - הפרוטוטייפ = דמו מהיר, Schema = יישום production-ready

**הערה:** אם צריך, אפשר ליצור Schema מוקדם יותר, אבל הסדר המומלץ הוא Prototype → Schema כדי למנוע שינויים מיותרים בסכמה.

---

## מה הופך את האלגוריתם לייחודי?

### 1. **התאמה אוטומטית למורכבות**
רוב הכלים עובדים באותו אופן לכל פרויקט. כאן:
- פרויקט פשוט = פחות שאלות, פחות קבצים, workflow קצר
- פרויקט מורכב = שאלות מעמיקות, פירוק למודולים, workflow מלא

**למה זה חשוב?** לא מבזבזים זמן על דברים מיותרים, אבל גם לא מדלגים על פרטים קריטיים.

### 2. **שכבות מובנות (Layered Architecture)**
המפרט מאורגן בשכבות לוגיות:
- `project/` - מידע כללי על הפרויקט
- `entities/` - מודלים של נתונים
- `roles/` - תפקידי משתמשים
- `guards/` - כללי גישה
- `routes/` - דפים ומסכים
- `use-cases/` - תרחישי שימוש
- `components/` - רכיבי UI
- `events/` - אירועים במערכת

**למה זה חשוב?** כל שכבה תלויה בקודמתה, מה שיוצר סדר לוגי ומונע טעויות.

### 3. **יחסים אוטומטיים (Relations Graph)**
המערכת בונה אוטומטית גרף של קשרים:
- איזה entity קשור לאיזה
- איזה use-case משתמש באיזה entity
- איזה guard מגן על איזה route

**למה זה חשוב?** רואים את התמונה המלאה, מונעים טעויות, מבינים את ההשפעות של שינויים.

### 4. **דיאלוג מובנה עם LLM**
המערכת לא רק שואלת שאלות - היא יודעת:
- מתי לשאול (לפי השלב)
- כמה לשאול (לפי הפרופיל)
- מה לשאול (לפי השכבה)

**למה זה חשוב?** LLM עובד בצורה יעילה וממוקדת, לא מבלבל את המשתמש.

### 5. **יצירה אוטומטית מקבצים**
מאותם קבצי TOML נוצרים:
- **תיעוד** - פורטל יפה עם כל המידע
- **פרוטוטייפ** - אפליקציה React עובדת
- **סכמה** - Prisma schema למסד נתונים

**למה זה חשוב?** כתיבה אחת = שלושה תוצרים. אין צורך לשמור סינכרון ידני.

---

## דוגמה: איך האלגוריתם עובד בפועל

### תרחיש: פרויקט Medium (SaaS)

1. **Assessment:**
   - סוג: web-app
   - תפקידים: 3 (visitor, user, admin)
   - נתונים: יחסיים (users, products, orders)
   - אינטגרציות: כמה APIs
   - **החלטה:** Profile = Medium

2. **Discovery:**
   - שאלות מפורטות על הבעיה, הקהל, הערך
   - יצירת `project/about.toml`, `project/business.toml`

3. **Design:**
   - שאלות על עיצוב, צבעים, responsive
   - יצירת `project/design.toml`

4. **Access Control:**
   - הגדרת 3 תפקידים
   - הגדרת guards לכל route
   - יצירת `roles/*.toml`, `guards/*.toml`

5. **Data Model:**
   - הגדרת entities: User, Product, Order
   - הגדרת relations: User → Orders, Product → Orders
   - יצירת `entities/*.toml`

6. **Features:**
   - הגדרת use-cases: "view products", "create order"
   - הגדרת routes: `/products`, `/orders`
   - יצירת `use-cases/*.toml`, `routes/*.toml`

7. **Prototype:**
   - יצירת mock data מה-entities
   - יצירת דפי React
   - חיווט ניווט וטפסים

8. **Schema:**
   - יצירת Prisma schema מה-entities
   - הוספת relations ו-indexes

**תוצאה:** פרויקט מלא עם תיעוד, פרוטוטייפ, וסכמה - הכל מאותם קבצים.

---

## למה זה עובד טוב יותר?

### בעיות שזה פותר:

1. **תיעוד מתיישן** - כאן התיעוד נוצר מהמפרט, אז הוא תמיד מעודכן
2. **פרוטוטייפ לא תואם למפרט** - כאן הפרוטוטייפ נוצר מאותו מקור
3. **סכמה לא תואמת למודלים** - כאן הסכמה נוצרת מאותם entities
4. **בזבוז זמן על שאלות מיותרות** - כאן השאלות מותאמות למורכבות
5. **חוסר סדר במפרט** - כאן יש מבנה שכבות מובנה

### יתרונות:

- **מהירות** - מ-רעיון לפרוטוטייפ עובד תוך שעות, לא ימים
- **עקביות** - כל התוצרים תמיד מסונכרנים
- **איכות** - מבנה מובנה מונע טעויות
- **גמישות** - מתאים לכל סוג פרויקט
- **שקיפות** - כל המידע נגיש ונראה

---

## סיכום: מה הייחודיות?

1. **אבלוריתם אדפטיבי** - מתאים את עצמו למורכבות הפרויקט
2. **מקור אמת אחד** - הכל נוצר מאותם קבצים
3. **שכבות מובנות** - מבנה לוגי שמנחה את התהליך
4. **דיאלוג מובנה** - LLM יודע בדיוק מה לשאול ומתי
5. **יצירה אוטומטית** - תיעוד + פרוטוטייפ + סכמה מאותו מקור

**הרעיון המרכזי:** במקום לכתוב קוד ואז לתעד, או לתכנן ואז לשכוח - כאן מתכננים בקבצים פשוטים, והכל נוצר אוטומטית.
